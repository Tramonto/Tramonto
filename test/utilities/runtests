#!/usr/bin/perl -w
# /Tramonto/test/utilities/runtests

################################################################################
# The Tramonto Project - runtests
# 
# Mike Phenow, Jim Willenbring
#
# This is a utility for running Tramonto packages tests.  It assumes you have
# an existing build directory containing properly configured and built 
# packages and tests.  It also requires that packages have test definition 
# files in thier test directory.
#
################################################################################

use strict;

# Variable Declarations ========================================================

# Command line arguments:

my $tramontoDir;        # Tramonto directory        (required argument) 
my $buildDir;           # build directory           (required argument) 
my $category;           # test category             (required argument) 
my $maxProc;            # maximum processors        (default: 4)
my $mpiStart;           # mpi startup command       (default: NONE)
my $mpiPing;            # mpi ping command          (default: NONE)
my $mpiStop;            # mpi shutdown command      (default: NONE)
my $mpiGo;              # mpi-go command            (default: mpirun -np )
my $shortCircuit;       # quit with a non-zero exit code as soon as anything fails

my $outputDir;          # output directory          (default: .)
my $simpleDirName;      # leave off timestamp for sake of database reporting
my $coverage;           # compute coverage data

my $verbosity;          # verbosity level           (default: 1)
my $logVerbosity;       # log file verbosity level  (default: 0)

my @testListAoH;        # test list array of hash
                        #   'directory'     =>  vector/
                        #   'name'          =>  test.exe
                        #   'exitStatus'    =>  [compareTestOutput,STRING-COMPARISON,RETURN-CODE]
                        #   'passString'    =>  my test passed string
                        #   'commandFile'   =>  my_command_file
                        #   'masterFile'    =>  my_master_file

my $resultsDir;         # absolute path to results directory
my $runStartTime;       # time runtests started

# Constants
my $v0 = "0";           # quiet
my $v1 = "1";           # normal verbosity
my $v2 = "2";           # level 2 verbosity
my $v3 = "4";           # level 3 verbosity
        
################################################################################
# Execution ####################################################################
################################################################################

getArgs();
init();
run();
cleanUp();

################################################################################
# Subroutines ##################################################################
################################################################################

    ############################################################################
    # getArgs()
    #
    # Parse command line arguments.
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub getArgs {
        
        # Argument variables that don't need to be global.
        my $quiet;
        my $help;

        # Gather command line arguments.
        use Getopt::Long;
        GetOptions( "tramonto-dir=s" => \$tramontoDir,
                    "build-dir=s" => \$buildDir,
                    "category=s" => \$category,
                    "max-proc=i" => \$maxProc,
                    "mpi-start=s" => \$mpiStart,
                    "mpi-ping=s" => \$mpiPing,
                    "mpi-stop=s" => \$mpiStop,
                    "mpi-go=s" => \$mpiGo,
                    "short-circuit" => \$shortCircuit,
                    "output-dir=s" => \$outputDir,
                    "simple-dir-name" => \$simpleDirName,
                    "coverage" => \$coverage,
                    "verbosity=i" => \$verbosity,
                    "log-verbosity=i" => \$logVerbosity,
                    "quiet" => \$quiet,
                    "help" => \$help );

        # Print help and exit.
        if ($help) { 
            printHelp();
            exit;
        }
        
        # Enforce and/or prepare arguments.
        
        # check for existance of tramonto-dir argument and actual directory.
        if (!$tramontoDir) {
            die "tramonto-dir value required, see --help for more information\n"; 
        } else {
            if (!stat($tramontoDir)) {
                die "cannot stat tramonto-dir: $tramontoDir\n";
            }
        }
        
        # Check for existance of build-dir argument and actual directory.
        # If it isn't given as an absolute path, prepend the Tramonto path.
        if (!$buildDir) {
            die "build-dir value required, see --help for more information\n"; 
        } else {
            if ($buildDir !~ m/^\//) {
                $buildDir = "$tramontoDir/$buildDir";
            }
            if (!stat($buildDir)) {
                die "cannot stat build-dir: $buildDir\n";
            }
        }
        
        # Check for existance and acceptable value of category argument.
        # This may be changed from a 'die' to a 'warn' in the future if
        # developers decide they want to define their own, non-standard groups.
        if (!$category) {
            die "category value required, see --help for more information\n"; 
        } 
        
        # Check for existance of max-proc.
        if (!$maxProc) {
            $maxProc = 4;   # reasonable guess?
        } else {
            if ($maxProc < 1) {
                die "max-proc value must be at least 1\n";
            }
        }
        
        # Check for valid mpi-start command.
        if ($mpiStart) { 
            $mpiStart =~ m/^(\S+)/;
            my $mpiStartProg = $1;
            `which $mpiStartProg`;
            if ($?) {
                die "cannot find mpi-start command: $mpiStartProg\n";
            }
        } else {
            $mpiStart = ""; 
        }
        
        # Check for valid mpi-ping command.
        if ($mpiPing) { 
            $mpiPing =~ m/^(\S+)/;
            my $mpiPingProg = $1;
            `which $mpiPingProg`;
            if ($?) {
                die "cannot find mpi-ping command: $mpiPingProg\n";
            }
        } else {
            $mpiPing = ""; 
        }
        
        # Check for valid mpi-stop command.
        if ($mpiStop) {
            $mpiStop =~ m/^(\S+)/;
            my $mpiStopProg = $1;
            `which $mpiStopProg`;
            if ($?) {
                die "cannot find mpi-stop command: $mpiStopProg\n";
            }
        } else {
            $mpiStop = ""; 
        }
        
        # Check for valid mpi-go command and set mpi-go environment variable.
        if (!$mpiGo) { 
            $mpiGo = "mpirun -np "; 
        }
        $mpiGo =~ m/^(\S+)/;
        my $mpiGoProg = $1;
        `which $mpiGoProg`;
        if ($?) {
            die "cannot find mpi-go command: $mpiGoProg\n";
        } else {
            $ENV{'TRAMONTO_TEST_HARNESS_MPIGO_COMMAND'} = $mpiGo;
        }
        
        # Check for existance of output directory, use it to create the
        # complete path for the results directory, and create the results
        # directory.
        if (!$outputDir) {
            $outputDir = "";
            $resultsDir = "$tramontoDir/test/utilities/results"; 
        } else {
            if ($outputDir =~ m/^\//) {
                $resultsDir = $outputDir;
            } else {
                $resultsDir = "$tramontoDir/test/utilities/$outputDir";
            }
        }
        if (!stat($resultsDir)) {
            system("mkdir $resultsDir") == 0 or die "cannot create $resultsDir, died";
        }
        
        # Set verbosity level to corresponding constant.  0, 1, 2, and 3 are
        # used for the levels the user may specify, but they are stored as 0,
        # 1, 2, and 4 so they can be combined and processed with bitwise
        # operations.
        if ($verbosity) {
            if      ($verbosity == 0) { $verbosity = $v0; }
            elsif   ($verbosity == 1) { $verbosity = $v1; }
            elsif   ($verbosity == 2) { $verbosity = $v2; }
            elsif   ($verbosity == 3) { $verbosity = $v3; }
        } else {
            $verbosity = $v1; 
        }
        
        # Set log verbosity level to corresponding constant.  Numbering scheme
        # is the same for the log verbosity as it is for the standard verbosity.
        # There is not distinct output and log output, the if a log verbosity
        # is given, then that level of output is written to a file instead of
        # to standard out.  
        if ($logVerbosity) {
            if      ($logVerbosity == 0) { $logVerbosity = $v0; }
            elsif   ($logVerbosity == 1) { $logVerbosity = $v1; }
            elsif   ($logVerbosity == 2) { $logVerbosity = $v2; }
            elsif   ($logVerbosity == 3) { $logVerbosity = $v3; }        
        } else {
            $logVerbosity = $v1; 
        }
        
        # Set quiet mode--same as passing --verbosity=0.
        if ($quiet) {
            $verbosity = $v0; 
        }            
        
    } # getArgs()

    ############################################################################
    # init()
    #
    # Prepares varibles.
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub init {
           
        # Capture and format start time.
        (my $se, my $mn, my $hr, my $da, my $mo, my $yr) = (localtime)[0..5];
        $yr = sprintf("%02d", $yr % 100);
        $mo = sprintf("%02d", $mo+1);
        $da = sprintf("%02d", $da);
        $hr = sprintf("%02d", $hr);
        $mn = sprintf("%02d", $mn);
        $se = sprintf("%02d", $se);
        $runStartTime = $yr."-".$mo."-".$da."_".$hr.".".$mn.".".$se;
        
        # Create results directory.
        if (!$simpleDirName) {
            $resultsDir .= "/$runStartTime-test";
        } else {
            $resultsDir .= "/test";
        }
        system("mkdir $resultsDir") == 0 or die "cannot create $resultsDir, died";
        
        # Print list of variables for debugging.
        my $message = "";
        $message .= "init():\n";
        $message .= "  \$tramontoDir = $tramontoDir\n";
        $message .= "  \$buildDir = $buildDir\n";
        $message .= "  \$category = $category\n";
        $message .= "  \$maxProc = $maxProc\n";
        $message .= "  \$mpiStart = $mpiStart\n";
        $message .= "  \$mpiPing = $mpiPing\n";
        $message .= "  \$mpiStop = $mpiStop\n";
        $message .= "  \$mpiGo = $mpiGo\n";
        $message .= "  \$outputDir = $outputDir\n";
        $message .= "  \$verbosity = $verbosity\n";
        $message .= "  \$logVerbosity = $logVerbosity\n";
        $message .= "  \$runStartTime = $runStartTime\n";
        $message .= "  \$resultsDir = $resultsDir\n";
        $message .= "  \n";
        printMessage($message, $v3);
        
    } # init()
    
    ############################################################################
    # run()
    #
    # Moves into build-dir/packages, looks for files and runs tests based on
    # @testListAoH compiled by compileTestList.
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub run {
        
        # Grab general information values for inclusion in machine info file. 
        my $hostName = "";          my $dnsName = "";           my $ipAddress = "";     
        my $operatingSystem = "";   my $kernelName = "";        my $kernelRelease = "";
        my $kernelVersion = "";     my $processor = "";         my $machineHardware = "";
        my $hardwarePlatform = "";  my $badCmd = 0;          
        $badCmd = system('hostname -s > /dev/null 2>&1');
        if (!$badCmd) {
            chomp($hostName=`hostname -s`);
        } else {
            $hostName=getOptionalOutput("uname -n");
        }
        $dnsName=getOptionalOutput("hostname -d");
        $ipAddress=getOptionalOutput("hostname -i");
        $operatingSystem=getOptionalOutput("uname -o");
        $kernelName=getOptionalOutput("uname -s");
        $kernelRelease=getOptionalOutput("uname -r");
        $kernelVersion=getOptionalOutput("uname -v");
        $processor=getOptionalOutput("uname -p");
        $machineHardware=getOptionalOutput("uname -m");
        $hardwarePlatform=getOptionalOutput("uname -i");
        # Grab the repository branch tag
        my $branchTag = "";
        my $homeDirContents = `ls $tramontoDir`;
        if ($homeDirContents =~ m/CVS/) {
            my $cvsDirContents = `ls $tramontoDir/CVS`;
            if ($cvsDirContents =~ m/Tag/) {
                $branchTag = `cat $tramontoDir/CVS/Tag`;
                $branchTag =~ s/^T//;
            } else {
                $branchTag = "development";
            }      
        } else {
            $branchTag = "unknown";
        }    
                
        # cd to Examples directory
        chdir $tramontoDir or die "cannot chdir to $tramontoDir, died";
        chdir "Examples/" or die "cannot chdir to Examples/, died";
        
        my @exampleDirs = ();
        if (opendir(DIR, ".")) {
            while (defined (my $file = readdir(DIR))) {
                my $absFile = "$tramontoDir/Examples/$file";
                if (-d $absFile) {
                    use File::Basename;
                    my $dirName = basename($absFile); 
                    if ($dirName ne "CVS" && $dirName ne "." 
                      && $dirName ne ".." && $dirName ne "Ex_polyfiles") {
                        push(@exampleDirs, $absFile); 
                    } 
                }
            }
            closedir(DIR);
        }

        # Start MPI
        if ($mpiStart) { system("$mpiStart 1>/dev/null 2>/dev/null"); }
        
        my $examplesTotal = 0;
        my $examplesPassed = 0;
        my $examplesFailed = 0;
        
        # run examples
        @exampleDirs = sort(@exampleDirs);
        foreach my $exampleDir (@exampleDirs) {
            chdir $exampleDir or die "cannot chdir to $exampleDir, died";

            use File::Basename;
            my $example = basename($exampleDir);

            # If valid mpi-ping command, check to see if mpi is running and,
            # if not, restart it.
            if ($mpiPing && system("$mpiPing 1>/dev/null 2>/dev/null")) {
                if ($mpiStart) { system("$mpiStart 1>/dev/null 2>/dev/null"); }
            }
                
            # Print progress message.
            my $message = "";
            $message = $example."...";
            $message = sprintf("%-55s", $message);
            printMessage($message, $v1+$v2+$v3);

            # Blow away dft_output.dat if it exists
            system("rm -rf dft_output.dat");
        
            # Capture and format test start time.
            (my $se, my $mn, my $hr, my $da, my $mo, my $yr) = (localtime)[0..5];
            $yr = sprintf("%02d", $yr % 100);
            $mo = sprintf("%02d", $mo+1);
            $da = sprintf("%02d", $da);
            $hr = sprintf("%02d", $hr);
            $mn = sprintf("%02d", $mn);
            $se = sprintf("%02d", $se);
            my $exampleStartTime = $yr."-".$mo."-".$da." ".$hr.":".$mn.":".$se;
            my $exampleStartTimeForFilename = $yr."-".$mo."-".$da."_".$hr.".".$mn.".".$se;
            my $startSeconds = time();
        
            # run example
            my $exampleCommand = "mpirun -np 4 ../../BUILD/src/dft 2>&1";
            my $exampleOutput = `$exampleCommand`;
            my $exampleExitStatus = $?;
        
            # trim ouput
            $exampleOutput = substr ($exampleOutput, -1000000);
            
            # parse output for real pass/fail status
            if (!$exampleExitStatus) {

                # Open README for reading.
                open (README, "<README") 
                  or die "Can't open README, died";
                    
                # Read README into one string.
                undef $/;               # undefine input record separator
                my $readme=<README>;    # copy entire file
                $/ = "\n";              # restore it to default newline
                close README;
                
                # grab "Key Output Parameters section
                if ($readme =~ m/Key Output Parameters:(.*)$/s) {
                    my $keyParamsString = $1;
                    $keyParamsString =~ s/#.*$//mg;  # remove comments
                    my @keyParams = ();
                    my @lines = $keyParamsString =~ m/^(.*)$/mg;
                    foreach my $line (@lines) {
                      if ($line =~ m/^\s*-\s*\S+\s*=\s*(-?[0-9.]+)\s*$/) {
                        my $keyParam = $1;
                        push(@keyParams, $keyParam);
                      }
                    }

                    # Open dft_output.dat for reading.
                    open (DFT_OUTPUT, "<dft_output.dat")
                      or die "Can't open dft_output.dat, died";

                    # Read dft_output.dat into one string.
                    undef $/;
                    my $dftOutput=<DFT_OUTPUT>;
                    $/ = "\n";
                    close DFT_OUTPUT;

                    my $misses = 0;
                    foreach my $keyParam (@keyParams) {
                      if ($dftOutput !~ m/\s$keyParam\s/) {
                        $misses++;
                      }
                    }

                    if ($misses) {
                      $exampleExitStatus = $misses;
                    }
                    
                } else {
                    $exampleExitStatus = -1;    
                    $message = "no \"Key Output Parameters\" section";
                    printMessage($message, $v1+$v2,$v3);
                }

            }
                
            # Tally result
            $examplesTotal++;
            if ($exampleExitStatus) { $examplesFailed++; }
            else { $examplesPassed++; }
        
            # Capture and format test stop time.
            ($se, $mn, $hr, $da, $mo, $yr) = (localtime)[0..5];
            $yr = sprintf("%02d", $yr % 100);
            $mo = sprintf("%02d", $mo+1);
            $da = sprintf("%02d", $da);
            $hr = sprintf("%02d", $hr);
            $mn = sprintf("%02d", $mn);
            $se = sprintf("%02d", $se);
            my $exampleStopTime = $yr."-".$mo."-".$da." ".$hr.":".$mn.":".$se;
            my $stopSeconds = time();            
            my $runSeconds = $stopSeconds - $startSeconds;
                            
            # Print pass/fail message.
            $message = ($exampleExitStatus==0?"  passed ":"! FAILED ");
            printMessage($message, $v1+$v2+$v3);
            $message = ($runSeconds==0?"<1":$runSeconds);
            $message = sprintf("%6s", $message);
            printMessage($message, $v1+$v2+$v3);
            $message = " second".($runSeconds>1?"s":"")."\n";
            printMessage($message, $v1+$v2+$v3);

            # Open README for reading.
            open (README, "<README") 
              or die "Can't open README, died";
    
            # Read README into one string.
            undef $/;                      # undefine input record separator
            my $exampleReadme=<README>;    # copy entire file
            $/ = "\n";                     # restore it to default newline
            close README;
                
	        # Open dft_output.dat for reading.
	        open (DFT_OUTPUT, "<dft_output.dat")
	          or die "Can't open dft_output.dat, died";

	        # Read dft_output.dat into one string.
	        undef $/;
	        my $dftOutput=<DFT_OUTPUT>;
	        $/ = "\n";
	        close DFT_OUTPUT;

            # Rename dft_output.dat file for archival purposes
            system("mv dft_output.dat dft_output_$exampleStartTimeForFilename.dat");

            # Grab timing info
            $exampleOutput =~ m/^TOTAL TIME\s+\S+\s+([0-9.]+)\s*$/m;
            my $exampleTiming = $1;
            
            # Create results file.
            my $resultsFile = "$resultsDir/";
            $resultsFile .= $example."_";
            
            my $exampleNumber = "00";
            while (stat "$resultsFile"."$exampleNumber.txt") {
                $exampleNumber++;
            }           
            $resultsFile .= $exampleNumber.".txt";
            open (RESULTS, ">$resultsFile") 
                or die "can't open test result file $resultsFile for writing, died";
                
            my $resultsString = "";
            
            $resultsString .= "HOST_NAME            = $hostName\n";
            $resultsString .= "DNS_NAME             = $dnsName\n";
            $resultsString .= "IP_ADDRESS           = $ipAddress\n";
            $resultsString .= "OPERATING_SYSTEM     = $operatingSystem\n";
            $resultsString .= "KERNEL_NAME          = $kernelName\n";
            $resultsString .= "KERNEL_RELEASE       = $kernelRelease\n";
            $resultsString .= "KERNEL_VERSION       = $kernelVersion\n";
            $resultsString .= "PROCESSOR            = $processor\n";
            $resultsString .= "MACHINE_HARDWARE     = $machineHardware\n";
            $resultsString .= "HARDWARE_PLATFORM    = $hardwarePlatform\n";
            $resultsString .= "\n";
            $resultsString .= "TRAMONTO_DIR         = $tramontoDir\n";
            $resultsString .= "BRANCH_TAG           = $branchTag\n";
            $resultsString .= "\n";
            $resultsString .= "BUILD_DIR            = $buildDir\n";
            $resultsString .= "\n";
            $resultsString .= "TEST_CATEGORY        = $category\n";
            $resultsString .= "TEST_DIR             = $exampleDir\n";
            $resultsString .= "TEST_NAME            = $example\n";
            $resultsString .= "TEST_NUMBER          = $exampleNumber\n";
            $resultsString .= "\n";
            $resultsString .= "COMMAND              = $exampleCommand\n";
            $resultsString .= "START_TIME           = $exampleStartTime\n";
            $resultsString .= "STOP_TIME            = $exampleStopTime\n";
            $resultsString .= "RUN_TIME             = ".($runSeconds==0?"<1":$runSeconds)." seconds\n";
            $resultsString .= "TEST_TIMING          = $exampleTiming\n";
            $resultsString .= "\n";
            $resultsString .= "EXIT_STATUS          = $exampleExitStatus\n";
            $resultsString .= "RESULT               = ".($exampleExitStatus==0?"pass":"fail")."\n";
            $resultsString .= "\n";
            $resultsString .= "TEST_OUTPUT {{{\n\n$exampleOutput\n\n}}}\n";
            $resultsString .= "\n";
            $resultsString .= "README {{{\n\n$exampleReadme\n\n}}}\n";
            $resultsString .= "\n";
            $resultsString .= "DFT_OUTPUT {{{\n\n$dftOutput\n\n}}}\n";

            print RESULTS $resultsString;
            
            close RESULTS;
            
            # Create timings file if it doesn't already exist.
            my $timingsFile = "$resultsDir/timings.txt";
            
            my $timingsString = "";
            
            if (! -e $timingsFile) {
                
                open (TIMINGS, ">$timingsFile") 
                    or die "can't open file $timingsFile for writing, died";
                
                $timingsString .= "HOST_NAME            = $hostName\n";
                $timingsString .= "DNS_NAME             = $dnsName\n";
                $timingsString .= "IP_ADDRESS           = $ipAddress\n";
                $timingsString .= "OPERATING_SYSTEM     = $operatingSystem\n";
                $timingsString .= "KERNEL_NAME          = $kernelName\n";
                $timingsString .= "KERNEL_RELEASE       = $kernelRelease\n";
                $timingsString .= "KERNEL_VERSION       = $kernelVersion\n";
                $timingsString .= "PROCESSOR            = $processor\n";
                $timingsString .= "MACHINE_HARDWARE     = $machineHardware\n";
                $timingsString .= "HARDWARE_PLATFORM    = $hardwarePlatform\n";
                $timingsString .= "\n";
                $timingsString .= "BRANCH_TAG           = $branchTag\n";
                $timingsString .= "TRAMONTO_DIR         = $tramontoDir\n";
                $timingsString .= "BUILD_DIR            = $buildDir\n";
                $timingsString .= "RUNTESTS_START_TIME  = $runStartTime\n";
                $timingsString .= "NUM_PROCESSORS       = $maxProc\n";
                $timingsString .= "\n";
                $timingsString .= "\n";

            } else { 
                open (TIMINGS, ">>$timingsFile") 
                    or die "can't open file $timingsFile for writing, died";
            }

            $timingsString .= sprintf("%-40s", $example);
            $timingsString .= "$exampleTiming\n";

            print TIMINGS $timingsString;
            
            close TIMINGS;
            
            # Bail if there's a failure and we're in short-circuit mode.
            if ($shortCircuit && $exampleExitStatus) {
                print "short-circuit mode:  test failed:  quitting.\n";
                return 77;
            }
        
        } # foreach example directory
            
        # Print test summary.
        my $message = "";
        $message = "\n";
        $message .= "  Tests Passed: ".sprintf("%3s", "$examplesPassed")."\n";
        $message .= "  Tests Failed: ".sprintf("%3s", "$examplesFailed")."\n";
        $message .= " -------------------\n";
        $message .= "  Tests Total:  ".sprintf("%3s", "$examplesTotal")."\n\n";
        printMessage($message, $v1+$v2+$v3);
        
        # Stop MPI
        if ($mpiStop) { system("$mpiStop 1>/dev/null 2>/dev/null"); }
        
        # Perform coverage tasks.
        if ($coverage) { coverage(); }
        
    } # run()
    
    ############################################################################
    # coverage()
    #
    # Perform coverage tasks.
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub coverage {
    
        chdir $tramontoDir or die "cannot chdir to $tramontoDir, died";
        
        my $command = "./test/coverage/gcovmerge --with-directories ";
        $command .= "--exclude=test/ --exclude=example/ --exclude=examples/ ";
        $command .= "--exclude=doc/ --source-dir=$tramontoDir/packages --with-count ";
        $command .= "--with-percent --with-full-paths $buildDir/packages";
        my $output = `$command`;
        my $exitStatus = $?;
        
        chdir $resultsDir or die "cannot chdir to $resultsDir, died";
        mkdir "coverage" or die "cannot create directory \"coverage\", died";
        
        my $summaryFile = "$resultsDir/coverage.txt";
        open (SUMMARY, ">$summaryFile") 
            or die "can't open test coverage summary file $summaryFile for writing, died";
              
        print SUMMARY $output;        
        close SUMMARY;
        
        use File::Find;
        find (\&createTree, ("$buildDir/packages"));
        find (\&copyGcov, ("$buildDir/packages"));
        
    } # coverage()
    
    ############################################################################
    # createTree()
    #
    # Create directory tree under test/coverage
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub createTree {
    
        use File::Basename;
        my $absFile = $File::Find::name;
        my $file = basename($absFile);
        my $dir = dirname($absFile);
        
        # Is this file a directory?
        if (-e $file && -d $file && $file ne "packages" && $file ne "CVS") {
        
            my $destination = $absFile;
            $destination =~ s/$buildDir\/packages/$resultsDir\/coverage/;
            
            if (!(-e $destination && -d $destination)) {
                mkdir "$destination" or die "cannot create directory $destination, died";   
            }
        
        }
           
    } # createTree()
    
    ############################################################################
    # copyGcov()
    #
    # Copy all .gcov files
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub copyGcov {
    
        use File::Basename;
        my $absFile = $File::Find::name;
        my $file = basename($absFile);
        my $dir = dirname($absFile);
        
        if ($file =~ m/\.gcov$/) {
            
            my $destination = $dir;
            $destination =~ s/$buildDir\/packages/$resultsDir\/coverage/;
            
            my $output = `cp $absFile $destination`;
            my $exitStatus = $?;
        
        }
           
    } # copyGcov()
    
    ############################################################################
    # cleanUp()
    #
    # Clean up environment variables, temp files, etc.
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub cleanUp {
    
        delete $ENV{'TRAMONTO_TEST_HARNESS_MPIGO_COMMAND'}; 
           
    } # cleanUp()
    
    ############################################################################
    # printMessage()
    #
    # Prints an event if the verbosity is set.
    #
    #   - args:     $message        (message to be printed)
    #               $level          (verbosity level of message)
    #
    #   - returns:  NONE
    #

    sub printMessage {
        my $message = $_[0];
        my $level = $_[1];
        
        if ($verbosity & $level) {
            print $message;
        }
        
        if ($logVerbosity & $level) {
            my $log = $resultsDir."/log.txt";
            open (LOG, ">>$log")
                or die "can't open $log";
            print LOG $message;
            close LOG;
        }
    } # printMessage()

    ############################################################################
    # getOptionalOutput()
    #
    # Runs a system command and gets its output if it succeeds then returns
    # its output.  The program suppress output to stderr of the program does
    # not run correctly.
    #
    #   - args:     the shell command
    #
    #   - returns:  the optional output string
    #

    sub getOptionalOutput {
      my $cmnd_in = shift;
      my $cmnd = "$cmnd_in > /dev/null 2>&1";
      my $returnVal = system($cmnd);
      my $outputStr="";
      chomp($outputStr = `$cmnd_in`) if($returnVal == 0);
      return $outputStr;
    } # getOptionalOutput()

    ############################################################################
    # printHelp()
    #
    # Prints help output.
    #
    #   - args:     NONE
    #
    #   - returns:  NONE
    #

    sub printHelp {
        print "runtests - The Tramonto Test Utility\n";
        print "\n";
        print "Usage:  perl runtests --tramonto-dir=/home/user/Tramonto --comm=mpi --build-dir=MPI\n";
        print "        --category=all\n";
        print "\n";
        print "Options:\n";
        print "\n";
        print "  --tramonto-dir=DIR     Specify the absolute path to the top-level Tramonto\n";
        print "                         directory that contains this program.\n";
        print "                         Example: /home/user/Tramonto\n";
        print "                         REQUIRED.\n";
        print "\n";
        print "  --comm=COMM            Specify the type of build, either \"serial\" or \"mpi\"\n";
        print "                         REQUIRED.\n";
        print "\n";
        print "  --build-dir=DIR        Specify the path of the build directory that contains\n";
        print "                         the tests you would like run.  If a relative path is\n";
        print "                         given, it is assumed that it is in the given Tramonto\n";
        print "                         directory.\n";
        print "                         REQUIRED.\n";
        print "\n";
        print "  --category=CATEGORY    Specify the category of tests to be run.  This must be\n";
        print "                         one of the predefined tests types:  FRAMEWORK,\n";
        print "                         CHECKIN, PERFORMANCE, SCALABILITY, or ALL.  See\n";
        print "                         README-definition for more information.\n";
        print "                         REQUIRED.\n";
        print "\n";
        print "  --max-proc=N           Specify the maximum number of processors on which to\n";
        print "                         run a test.\n";
        print "                         Default: 4\n";
        print "\n";
        print "  --mpi-start=COMMAND    Specify the mpi startup command for this system.\n";
        print "                         Default: NONE\n";
        print "\n";
        print "  --mpi-ping=COMMAND     Specify the mpi 'ping' or 'status' command for this system.\n";
        print "                         Default: NONE\n";
        print "\n";
        print "  --mpi-stop=COMMAND     Specify the mpi shutdown command for this system.\n";
        print "                         Default: NONE\n";
        print "\n";
        print "  --mpi-go=COMMAND       Specify the mpi-go command for this system.\n";
        print "                         Default: \"mpirun -np \"\n";
        print "\n";
        print "  --packages=P1[,P2]     Specify the packages to test.  Separate multiple\n";
        print "                         packages with commas.  Omit to test all built\n";
        print "                         packages with tests defined.\n";
        print "\n";
        print "  --short-circuit        Quit with a non-zero exit code as soon as\n";
        print "                         anything fails.\n";
        print "\n";
        print "  --output-dir=DIR       Specify the directory in which to create the directory\n";
        print "                         containing the test results.\n";
        print "                         Default: \".\"\n";
        print "\n";
        print "  --verbosity=LEVEL      0 = no non-fatal ouput (same as --quiet)\n";
        print "                         1 = normal output (default)\n";
        print "                         2 = level 2 verbosity\n";
        print "                         3 = level 3 verbosity\n";
        print "\n";
        print "  --log-verbosity=LEVEL  0 = no log\n";
        print "                         1 = normal output (default)\n";
        print "                         2 = level 2 verbosity\n";
        print "                         3 = level 3 verbosity\n";
        print "\n";
        print "  --quiet                Produce no non-fatal output.\n";
        print "\n";
        print "  --help                 Print this help output and exit.\n";
        print "\n";
        print "Notes:\n";
        print "  - For more information, see README-runtests in\n";
        print "    Tramonto/test/utilities/\n";
        print "    or visit http://software.sandia.gov/tramonto/developer/\n";
        print "\n";
    } # printHelp()
